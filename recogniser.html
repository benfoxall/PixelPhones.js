<!DOCTYPE html>
<html>
<head>
  <title>PixelPhones.js</title>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
  <h1>Recogniser</h1>
  <video autoplay muted></video>
  <canvas></canvas>
  <script type="text/javascript" src="cv.js"></script>
  <script type="text/javascript" src="common.js"></script>
  <script type="text/javascript">

    var stats = new Stats();
    stats.setMode(0);

    stats.domElement.style.position = 'absolute';
    stats.domElement.style.right = '0px';
    stats.domElement.style.top = '0px';

    document.body.appendChild( stats.domElement );



    navigator.getUserMedia = ( navigator.getUserMedia ||
                               navigator.webkitGetUserMedia ||
                               navigator.mozGetUserMedia ||
                               navigator.msGetUserMedia);


    var video     = document.querySelector('video'),
        canvas    = document.querySelector('canvas'),
        offcanvas = document.createElement('canvas');

    video.onloadedmetadata = initialise;

    video.onended = function(){
      stop = true;
      console.log("ended");

      // debug, draw matched contour bounding boxes
      var max = Contours.reduce(function(memo, item){
        return Math.max(memo, item.count)
      }, 0);

      console.log("max count", max);

      var ctx = canvas.getContext('2d');
      ctx.strokeStyle = 'red';
      ctx.strokeWidth = 1;
      ctx.fillStyle = 'rgba(0,255,0,0.5)';

      Contours.filter(function(c){return c.count > Math.min(2, max)})
      .forEach(function(c){
        var b = c.bounds;
        ctx.fillRect(b[0],b[1],b[2]-b[0],b[3]-b[1]);
        ctx.strokeRect(b[0],b[1],b[2]-b[0],b[3]-b[1]);
      })
    }

    /*
    navigator.getUserMedia(
      {video:true, audio:false}, 
      function(localMediaStream){
        video.src = window.URL.createObjectURL(localMediaStream);
      },
      console.error.bind(console)
    );
    */

    video.src="dev-video/office-basic.webm"


    function initialise(){
      canvas.width  = offcanvas.width  = video.videoWidth;
      canvas.height = offcanvas.height = video.videoHeight;

      render()
    }


    // a rolling list of observed contours {centroid, bounds, mass, density, count}
    var Contours = [];


    var greyLast = new CV.Image(), grey = new CV.Image(), thresh = new CV.Image();


    var cs = [], binary = [];


    var markers = [];

    var last;

    var stop;
    function render(){
      if(stop) return;
      requestAnimationFrame(render);
      stats.begin();

      // pull a frame from the video (could be offscreen)
      var ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0);
      var imageData      = ctx.getImageData(0,0, canvas.width, canvas.height);
      var imageDataClone = ctx.getImageData(0,0, canvas.width, canvas.height);

      if(last){

        CV.grayscale(imageData, grey);


        // find difference
        var _src = greyLast.data, _dest = grey.data;
        for (var i = _src.length - 1; i >= 0; i--) {
          // _src[i] = clamp(l)
          _dest[i] = clamp(_dest[i] - _src[i] + 125)
        };


        // CV.adaptiveThreshold(grey, thresh, 2, 7);

        CV.threshold(grey, thresh, 200);

        // imageData.data = grey.data;
        
        drawCVImage(thresh, imageData)

        // ctx.putImageData(imageData, 0,0)

        var c = CV.findContours(thresh, binary);
        cs.push(c);

        // Contours.push()

        var frameContours = c.map(contourProperties)

        contourReduce(Contours, frameContours)


        ctx.fillStyle = 'rgba(255,0,255,0.1)';
        Contours.forEach(function(c){
          var b = c.bounds;
          ctx.fillRect(b[0],b[1],b[2]-b[0],b[3]-b[1])
        })

        // the 'just observed' ones
        ctx.fillStyle = 'rgba(0,255,0,1)';
        frameContours.forEach(function(c){
          var b = c.bounds;
          ctx.fillRect(b[0],b[1],b[2]-b[0],b[3]-b[1])
        })


      }

      CV.grayscale(imageDataClone,greyLast);
      last = true;


      stats.end();
    }

    function clamp(n){
      if(n < 0) return 0;
      if(n > 255) return 255;
      return n
    }


// take an array of {x,y} give back bounds, mass, centroid & density
function contourProperties(contour){
  // due to the border-following contour search, the last item will be repeated
  var count = contour.length - 1,
      total_x = 0,
      total_y = 0,
      min_x = Infinity,
      min_y = Infinity,
      max_x = -Infinity,
      max_y = -Infinity,

      // to calculate the area given perimiter pixels
      sliceMap = {};

  for (var x, y, i = count - 1; i >= 0; i--) {
    x = contour[i].x;
    y = contour[i].y;

    total_x += x;
    total_y += y;
    min_x = Math.min(min_x, x);
    max_x = Math.max(max_x, x+1);
    min_y = Math.min(min_y, y);
    max_y = Math.max(max_y, y+1);

    if(sliceMap[x]){
      sliceMap[x][0] = Math.min(sliceMap[x][0], y);
      sliceMap[x][1] = Math.max(sliceMap[x][1], y+1);
    } else {
      sliceMap[x] =[y,y+1]
    }
  }

  var area = 0;
  for(x in sliceMap){
    area += sliceMap[x][1] - sliceMap[x][0]
  }

  return {
    bounds: [min_x, min_y, max_x, max_y],
    dimensions: [max_x-min_x, max_y-min_y],
    mass: area,
    centroid: [
      total_x/count, total_y/count
    ],
    density: area /  ((max_x - min_x)*(max_y - min_y)),
    source: contour,
    count:1
  }
}


function contourFilter(contour){
  return contour.mass > 25 && contour.density > 0.6;
}

function contourReduce(prior, next){
  var newContours = [];

  var min_x, max_x, min_y, max_y, min_mass, max_mass;
  next.forEach(function(c){
    // find a contour that matches this one
    min_x = c.centroid[0] - (c.dimensions[0]/2);
    max_x = c.centroid[0] + (c.dimensions[0]/2);
    min_y = c.centroid[1] - (c.dimensions[1]/2);
    max_y = c.centroid[1] + (c.dimensions[1]/2);
    min_mass = c.mass * 0.8;
    max_mass = c.mass * 1.2;

    var c_prior;
    for (var i = 0; i < prior.length -1; i++){
      c_prior = prior[i];

      if(!c_prior.centroid) debugger;

      if(
        c_prior.centroid[0] > min_x &&
        c_prior.centroid[0] < max_x &&
        c_prior.centroid[1] > min_y &&
        c_prior.centroid[1] < max_y &&
        c_prior.mass > min_mass &&
        c_prior.mass < max_mass
      ) {
        // update the existing node
        console.log("match found", i);
        c.count += c_prior.count;
        prior[i] = c;
        return;
      }
    };

    // if not, just add it
    newContours.push(c)
  })

  newContours.forEach(function(c){
    prior.push(c)
  });
}

function ColorTheBlobs(dst,blobs,colors){
    var xSize = dst.width,
        ySize = dst.height,
        dstPixels = dst.data,
        x, y, pos;

    var label, color, nColors = colors.length;

    for(y=0; y<ySize; y++){
        for(x=0; x<xSize; x++){
            pos = (y*xSize+x)*4;

            label = blobs[y][x];

            if( label !== 0 ){
                color = colors[ label % nColors ];
                dstPixels[ pos+0 ] = color[0];
                dstPixels[ pos+1 ] = color[1];
                dstPixels[ pos+2 ] = color[2];
                dstPixels[ pos+3 ] = color[3];
            }else{
                dstPixels[ pos+3 ] = 0;
            }
        }
    }

}


function drawCVImage(imSrc, imDest){
  var src = imSrc.data, dest = imDest.data;
  for (var i = src.length - 1; i >= 0; i--) {
    dest[i*4] = dest[(i*4)+1] = dest[(i*4)+2] = src[i];
  }
}

  </script>
</body>
</html>