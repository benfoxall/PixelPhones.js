<html>
<head>
  <title>PixelPhones.js</title>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
  <h1>Recogniser</h1>
  <!-- <video src="test.webm" autoplay loop></video> -->

  <video autoplay></video>
  <canvas></canvas>
  <script type="text/javascript" src="common.js"></script>
  <script type="text/javascript">

    var stats = new Stats();
    stats.setMode(0);

    stats.domElement.style.position = 'absolute';
    stats.domElement.style.right = '0px';
    stats.domElement.style.top = '0px';

    document.body.appendChild( stats.domElement );



    navigator.getUserMedia = ( navigator.getUserMedia ||
                               navigator.webkitGetUserMedia ||
                               navigator.mozGetUserMedia ||
                               navigator.msGetUserMedia);


    var video     = document.querySelector('video'),
        canvas    = document.querySelector('canvas'),
        offcanvas = document.createElement('canvas');

    video.onloadedmetadata = initialise;

    navigator.getUserMedia(
      {video:true, audio:false}, 
      function(localMediaStream){
        video.src = window.URL.createObjectURL(localMediaStream);
      },
      console.error.bind(console)
    );


    function initialise(){
      canvas.width  = offcanvas.width  = video.videoWidth;
      canvas.height = offcanvas.height = video.videoHeight;

      render()
    }



    var markers = [];

    var last;

    var stop;
    function render(){
      if(stop) return;
      requestAnimationFrame(render);
      stats.begin();

      // pull a frame from the video (could be offscreen)
      var ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0);
      var imageData      = ctx.getImageData(0,0, canvas.width, canvas.height);
      var imageDataClone = ctx.getImageData(0,0, canvas.width, canvas.height);

      if(last){
        var l = imageData.data.length, v, c;
        for (var i = 0; i < l; i += 4){
          // just red for now
          v = imageData.data[i] - last.data[i];
          // c = v < -100 ? 0 : 
          //     v >  100 ? 255 :
          //     155;

          // imageData.data[i] = imageData.data[i+1] = imageData.data[i+2] = c;
          imageData.data[i]   = v < -125 ? 255 : 0; // off -> on
          imageData.data[i+1] = v > 125 ? 255 : 0;  // on -> off
          imageData.data[i+2] = 0;
          // imageData.data[i+3] = 100;
        }


        // on
        var blobs_on  = FindBlobs(imageData,0);
        
        // off
        var blobs_off = FindBlobs(imageData,1);
  
        var i,j, i_l = blobs_on.length, j_l = blobs_on[0].length, idx,obj;

        var max = 0;

        // work out the positions and weights
        var totals = {};

        for(i = 0; i < i_l; i++){
          for(j = 0; j < j_l; j++){
            if(blobs_on[i][j]){
              obj = totals['on'+blobs_on[i][j]] = totals['on'+blobs_on[i][j]] || {
                x:0,y:0,c:0,type:'on'
              };

              obj.c++;
              obj.x+=j;
              obj.y+=i;

              // max = Math.max(max, blobs_on[i][j])
              // idx = (j*4) + (i*j_l*4);
              // imageData.data[idx + 2] = 255;
            }

            if(blobs_off[i][j]){
              obj = totals['off'+blobs_off[i][j]] = totals['off'+blobs_off[i][j]] || {
                x:0,y:0,c:0,type:'off'
              };

              obj.c++;
              obj.x+=j;
              obj.y+=i;

              max = Math.max(max, blobs_off[i][j])
              // idx = (j*4) + (i*j_l*4);
              // imageData.data[idx + 2] = 255;
            }
          }
        }

        console.log("MAX", max)
        if(max){
          console.log(totals);
          Object.keys(totals)
            .forEach(function(_t){
              var t = totals[_t];
              markers.push({
                x: t.x/t.c,
                y: t.y/t.c,
                r: Math.sqrt(t.c/Math.PI),
                ttl: 10,
                type: t.type
              })
            })
        }


        ctx.putImageData(imageData, 0,0)

        markers.forEach(function(m){
          m.ttl--;
          ctx.fillStyle = m.type == 'on' ? 
              'rgba(255,0,0,'+(m.ttl/10)+')' : 
              'rgba(0,255,0,'+(m.ttl/10)+')' ;
          ctx.beginPath();
          ctx.arc(m.x,m.y,m.r,0,2*Math.PI)
          ctx.fill()
        })

        markers = markers.filter(function(m){
          return m.ttl>0
        })
      }

      last = imageDataClone;


      stats.end();
    }

    function clamp(n){
      if(n < 0) return 0;
      if(n > 255) return 255;
      return n
    }


function ColorTheBlobs(dst,blobs,colors){
    var xSize = dst.width,
        ySize = dst.height,
        dstPixels = dst.data,
        x, y, pos;

    var label, color, nColors = colors.length;

    for(y=0; y<ySize; y++){
        for(x=0; x<xSize; x++){
            pos = (y*xSize+x)*4;

            label = blobs[y][x];

            if( label !== 0 ){
                color = colors[ label % nColors ];
                dstPixels[ pos+0 ] = color[0];
                dstPixels[ pos+1 ] = color[1];
                dstPixels[ pos+2 ] = color[2];
                dstPixels[ pos+3 ] = color[3];
            }else{
                dstPixels[ pos+3 ] = 0;
            }
        }
    }

}

  </script>
</body>
</html>